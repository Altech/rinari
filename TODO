# -*- mode: org -*-
# 
#+TITLE:     TODO
#+SEQ_TODO:  TODO MAYBE WAITING | DONE
#+DRAWERS:   SNIP

=TODO
List of pending work for rinari

for background see http://groups.google.com/group/emacs-on-rails

* unified runner for rails scripts

This is less a single runner, and more a single function from which
any rails/script can be executed associating the scripts with
appropriate buffers and modes.

Currently this
- runs console from a buffer in comint-mode
- runs server dumping output to a compilation-minor-mode buffer
- provides completion for generate/destroy
- runs all other scripts using shell-command-to-string dumping the
  output to a message

** DONE if web-server doesn't start change status message
currently there is no indication that the attempt to start the server
has failed

now has a sentinel, see [[elisp:(describe-function 'set-process-sentinel)]]

* DONE Name functions consistently
some global prefix for all of the function names, probably either
"rails" or "rinari"

going for rails for now
- easier to remember
- easy enough to change later

while I'm doing this I'm going to rename rails-scripts.rl to
rails-script.el (minor)

easy enough

* Make rinari a minor mode that doesn't activate for regular ruby-mode.
  :PROPERTIES:
  :assignee: eschulte
  :END:

** DONE define as a minor mode
** DONE when to enter rinari-minor-mode
this could be done through a hook that runs every time a .rb or .rhtml
file is loaded to check if it is inside of a rails project (using the
`rails-root' function or a .emacs-project file) and then to load
rinari-minor-mode appropriately

done with hooks on find-file and dired-mode

** DONE add key-bindings for rinari minor mode
should follow emacs key bindings

see [[info:elisp:Key%20Binding%20Conventions][info:elisp:Key Binding Conventions]]

:SNIP:
   * Sequences consisting of `C-c' followed by a control character or a
     digit are reserved for major modes.

   * Sequences consisting of `C-c' followed by `{', `}', `<', `>', `:'
     or `;' are also reserved for major modes.

   * Sequences consisting of `C-c' followed by any other punctuation
     character are allocated for minor modes.  Using them in a major
     mode is not absolutely prohibited, but if you do that, the major
     mode binding may be shadowed from time to time by minor modes.
:END:

given the above, it seems like an ergonomic option would be to start
all our rinari key-bindings with \C-c-' with \C-c-'-' running
something similar to \C-c\C-c in org-mode

** TODO key-bindings could probably use improvement
** TODO good minor mode documentation (like for \C-hm)

* WAITING make `rails-find-action' work with rails2-style view filenames
* make `rails-find-action' which will follow forms (maybe w/prefix?)
  :PROPERTIES:
  :assignee:  eschulte
  :END:

works for the following cases
- default (goes to the view with the name of the action)
- follows redirect_to another controller and action
- follows renders
- follows redirects to partials
- render_partial
- multiple renders (for example from separate clauses in an if
  statement)

can follow multiple redirects

** DONE enhancement
sometimes an action will have multiple redirect statements, in which
case this function should ask the user (with completion) which one to
follow

** TODO better error if run outside of controller

* TODO make rails-find-view follow forms around point
  :PROPERTIES:
  :assignee: eschulte
  :END:

* DONE revert and wrap find-file-in-project
  :PROPERTIES:
  :assignee: eschulte
  :END:

revert to the .emacs-project version of find-file-in-project so that
the actual find-file-in-project.el file remains unchanged.  Then using
defadvice wrap the ffip function to find the project base using
(rails-root) as well as the .emacs-project file.

* MAYBE add a function for running mysql
this would use the information in /conf/databases.yaml to log into the
application's database using sql-* functions from sql.el as
appropriate

* MAYBE errors / tests
something to speed up the cycle of

- coding
- testing
- jumping to errors

this should probably cash out into two different functions...

** rails-test-method

use `which-function' and the current buffer-file to find the current
function, then lookup and run the test related to that function
dumping the output into a compile buffer

maybe instead of using the current buffer-file change
[[file:rinari.el::defun%20rails%20name%20components%20name][rails-name-components-name]] so it returns the last component as well,
then change the controller usage of this function to drop the last
list element.  That way this can be used to get model names when
calling which-function from models/model.rb files.

Also, if you don't have a test written for this particular method this
could insert the def...end for the test into the appropriate file, and
drop the point there.  Nothing wrong with a little bit of soft
paternalism.

** rails-recent error

a function which either...
1) goes to the error closest to point in the current compilation mode
   buffer
2) goes to the most recent error in the *server*, *console*, or *test*
   buffer

See this discussion below from the emacs-on-rails list...

email discussion:
:SNIP:
> - maybe add a command which can jump to the most recent error (either
>   in the server logs, or in the console)

>  > That's a great idea. find-file-at-point is pretty good at doing this
>  > from test failures in eshell, but you have to move your point up to the
>  > line containing the error message. Leveraging logs and console output
>  > would be a great addition as would looking for lines somewhere other
>  > than just under the point.
>
> So there are two different possible ways to approach this...
>
> 1) through a function which searches in known places (eshell, logs,
>    consoles, server buffers, in current buffer) and makes an educated
>    guess about what to present to the user, possibly allowing quick
>    switching to the other errors.

Hmm... now that I think about it more, I'm not sure it's a good idea to
make it really convenient to go around digging through server logs to
find errors. The right way to go about solving that kind of problem is
to write a test for it. If you make it easier to fix the problem without
writing a test, really what that amounts to is short-term benefit but
long-term problems since your fix isn't guaranteed to be caught by the
test suite.

So I would discourage integration with the dev mongrel logs. The bonus
side of that is if we only have to help jump to errors/failures in test
output it becomes a lot easier. There are in my mind three common ways
of running tests:

- In an emacs shell, whether that's eshell, M-x shell, or ansi-term
- With compile-mode, as per the ruby-test-file function in rinari
- In a shell outside Emacs

So if we check console output it will work in the first two cases but
not in the last. I think it's best to always check the test logs, since
problems are pretty much guaranteed to be found in there. This also
solves the integration test problem; when you're running those and you
get an exception, the only console output you see is that you expected a
200 response but you got a 500, which is totally useless. In those cases
you have to check the logs anyway.

We could probably base this functionality on compilation mode. It's
already built to go over output looking for something that looks like a
stack trace and provide jumping to the source of the error:

http://www.emacswiki.org/cgi-bin/wiki/CompilationMode

> 2) wrap console, and server processes in insertion-filters which could
>    notice whenever an error passes through them, and save a pointer to
>    the error in some global rails-errors variable which could be
>    queried by jump-to-my-last-error type function
>
> I was originally leaning towards the latter, but now that you mention
> it the former might be easier... not sure

Yeah, the second one sounds a lot harder.
:END:

* TODO define macro for ido completion
since we often want to check the availability of ido for completing
reads it would probably be worth writing a macro to do this.

also, it may be worthwhile breaking utility functions out into a
separate file...




* buffer dictionary
 LocalWords:  rinari
